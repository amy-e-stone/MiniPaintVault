#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QSqlQuery> //  Allows executing SQL queries in Qt. (SQLite)
#include <QSqlError> // Handles errors that occur during SQL operations.
#include <QFileDialog> // To upload images
#include <QDebug> //  Provides debugging information.


MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    // Initialize the database (pass 'db' through the function)
    initializeDatabase();
}

MainWindow::~MainWindow()
{
    delete ui;
}

// All code above this comment was automatically generated by Qt Creator unless otherwise noted with a comment

void MainWindow::initializeDatabase()
{
    // Create an instance of QSqlDatabase, "QSQLITE" specifies the SQLite database driver.
    db = QSqlDatabase::addDatabase("QSQLITE");

    // Set database file name
    db.setDatabaseName("paint_inventory.db");

    // Open database
    if (!db.open()) {
         // 'qDebug()' starts the debug logging and is Qt specific, it is comparable to 'std::cout'
        qDebug() << "Error: Unable to connect to database!" << db.lastError();
    } else {
        qDebug() << "Database connected successfully!";
    }

    // Create query object which allows the execution of SQL commands (e.g., SELECT, INSERT, UPDATE, DELETE) on the connected database.
    QSqlQuery query;

    // SQL command to create table in the database (if it does not exist already)
    QString createTableQuery = "CREATE TABLE IF NOT EXISTS paints ("
                               "id INTEGER PRIMARY KEY AUTOINCREMENT, " // Define 'id' column with auto-increment with consecutive numbers
                               "brand TEXT, "
                               "color TEXT, "
                               "item_number TEXT, "
                               "type TEXT, "
                               "collection TEXT, "
                               "quantity TEXT, "
                               "shopping_list BOOL DEFAULT 0, "
                               "image_path TEXT)";

    // 'query.exec()' executes insert query that was prepared above
    if (!query.exec(createTableQuery)) {
         // 'qDebug()' starts the debug logging and is Qt specific, it is comparable to 'std::cout'
        qDebug() << "Error creating table: " << query.lastError();
    }
}


void MainWindow::on_buttonAddPaint_clicked()
{
    // Retrieve the text entered by the user in the input fields named inputBrand, inputColor, etc., and storing that text in the QString variable named brand, color, etc.
    QString brand = ui->inputBrand->text();
    QString color = ui->inputColor->text();
    QString itemNumber = ui->inputItemNum->text();
    QString type = ui->inputType->text();
    QString collection = ui->inputCollection->text();
    QString quantity = ui->inputQuantity->text();
    QString imagePath = selectedImagePath;

    // Create query object which allows the execution of SQL commands (e.g., SELECT, INSERT, UPDATE, DELETE) on the connected database.
    QSqlQuery query;

    // Prepare the query, inserting the new records brand, color etc. with the values :brand, :type, etc.
    query.prepare("INSERT INTO paints (brand, color, item_number, type, collection, quantity, image_path) VALUES (:brand, :color, :item_number, :type, :collection, :quantity, :image_path)");

    // Bind the input variable values to the respective placeholders
    query.bindValue(":brand", brand);
    query.bindValue(":color", color);
    query.bindValue(":item_number", itemNumber);
    query.bindValue(":type", type);
    query.bindValue(":collection", collection);
    query.bindValue(":quantity", quantity);
    query.bindValue(":image_path", imagePath);

    // 'query.exec()' executes insert query that was prepared above
    if (!query.exec()) {
         // 'qDebug()' starts the debug logging and is Qt specific, it is comparable to 'std::cout'
        qDebug() << "Error inserting data: " << query.lastError();
    } else {
        // Display the added items to the list of added paints
        ui->paintListWidget->addItem("Brand: " + brand + ", Color: " + color + ", Item Number: " + itemNumber + ", Type: " + type + ", Collection: " + collection + ", Quantity: " + quantity);
    }

    // Clear the input fields
    ui->inputBrand->clear();
    ui->inputColor->clear();
    ui->inputItemNum->clear();
    ui->inputType->clear();
    ui->inputCollection->clear();
    ui->inputQuantity->clear();
    selectedImagePath.clear();
}


void MainWindow::on_buttonDisplayPaints_clicked()
{
    // Sets the title of the list being displayed
    ui->labelListTitle->setText("Viewing All Paints");

    // SQL command to select all paints and paint attributes
    QSqlQuery query("SELECT id, brand, color, item_number, type, collection, quantity, image_path FROM paints");

    // Display the list in the table
    // Set column count and headers for QTableWidget, this includes 1 column for the checkboxes
    ui->paintTableWidget->setColumnCount(8);

    // Set the titles of each column in the table
    QStringList headers;

    // The first header is blank for the checkbox
    headers << "" << "Brand" << "Color" << "Item Number" << "Type" << "Collection" << "Quantity" << "Image";
    ui->paintTableWidget->setHorizontalHeaderLabels(headers);

    // Clear existing rows (refresh if there is a list is already displayed)
    ui->paintTableWidget->setRowCount(0);

    // Iterate through the results and populate the table
    int row = 0;
    while (query.next()) {
        ui->paintTableWidget->insertRow(row);

        // Represents an item in the QTableWidget, in this case it's a selection/checkbox for each row
        QTableWidgetItem *checkboxItem = new QTableWidgetItem();

        // Set the item's checkbox to be unchecked
        checkboxItem->setCheckState(Qt::Unchecked);

        // Assigns the value of the "id" field from the database query to the checkbox item using 'Qt::UserRole' (user defined data)
        // This allows the checkbox item to store the database ID for later use such as editing or deleting
        checkboxItem->setData(Qt::UserRole, query.value("id"));

        // Populate each row of the paintTableWidget with data retrieved from the database query.
        ui->paintTableWidget->setItem(row, 0, checkboxItem);

        // Need to convert to string because query.value(column_name) returns a 'QVariant' object that can hold any datatype
        ui->paintTableWidget->setItem(row, 1, new QTableWidgetItem(query.value("brand").toString()));
        ui->paintTableWidget->setItem(row, 2, new QTableWidgetItem(query.value("color").toString()));
        ui->paintTableWidget->setItem(row, 3, new QTableWidgetItem(query.value("item_number").toString()));
        ui->paintTableWidget->setItem(row, 4, new QTableWidgetItem(query.value("type").toString()));
        ui->paintTableWidget->setItem(row, 5, new QTableWidgetItem(query.value("collection").toString()));
        ui->paintTableWidget->setItem(row, 6, new QTableWidgetItem(query.value("quantity").toString()));

        // Display the image
        QString imagePath = query.value("image_path").toString();

        // Qlabel is a Qt class that displays an image or text
        // Create a pointer 'imageLabel', which points to a new instance of QLabel.
        QLabel *imageLabel = new QLabel();
        if (!imagePath.isEmpty()) {
            // setPixmap(...): Sets the scaled image to be displayed in the labelImage widget.
            // QPixmap(imagePath): Loads the image from the file path stored in imagePath
            imageLabel->setPixmap(QPixmap(imagePath).scaled(50, 50, Qt::KeepAspectRatio));
            // Store the image path in the QLabel property
            imageLabel->setProperty("imagePath", imagePath);
        }
        ui->paintTableWidget->setCellWidget(row, 7, imageLabel);

        row++;
    }
}


void MainWindow::on_buttonDisplayShoppingList_clicked()
{
    // Sets the title of the list being displayed
    ui->labelListTitle->setText("Viewing Shopping List");

    // SQL command to select items that are on the shopping list
    QSqlQuery query("SELECT id, brand, color, item_number, type, collection, quantity, image_path FROM paints WHERE shopping_list = 1");

    // Display the list in the table
    // Set column count and headers for QTableWidget, this includes 1 column for the checkboxes
    ui->paintTableWidget->setColumnCount(8);

    // Set the titles of each column in the table
    QStringList headers;

    // The first header is blank for the checkbox
    headers << "" << "Brand" << "Color" << "Item Number" << "Type" << "Collection" << "Quantity" << "Image";
    ui->paintTableWidget->setHorizontalHeaderLabels(headers);

    // Clear existing rows (refresh if there is a list is already displayed)
    ui->paintTableWidget->setRowCount(0);

    // Iterate through the results and populate the table
    int row = 0;
    while (query.next()) {
        ui->paintTableWidget->insertRow(row);

        // Represents an item in the QTableWidget, in this case it's a selection/checkbox for each row
        QTableWidgetItem *checkboxItem = new QTableWidgetItem();

        // Sets the item's checkbox to be unchecked
        checkboxItem->setCheckState(Qt::Unchecked);

        // Assigns the value of the "id" field from the database query to the checkbox item using 'Qt::UserRole' (user defined data)
        // This allows the checkbox item to store the database ID for later use such as editing or deleting
        checkboxItem->setData(Qt::UserRole, query.value("id"));

        // Populate each row of the paintTableWidget with data retrieved from the database query.
        ui->paintTableWidget->setItem(row, 0, checkboxItem);

        // Need to convert to string because 'query.value(column_name)' returns a 'QVariant' object that can hold any datatype
        ui->paintTableWidget->setItem(row, 1, new QTableWidgetItem(query.value("brand").toString()));
        ui->paintTableWidget->setItem(row, 2, new QTableWidgetItem(query.value("color").toString()));
        ui->paintTableWidget->setItem(row, 3, new QTableWidgetItem(query.value("item_number").toString()));
        ui->paintTableWidget->setItem(row, 4, new QTableWidgetItem(query.value("type").toString()));
        ui->paintTableWidget->setItem(row, 5, new QTableWidgetItem(query.value("collection").toString()));
        ui->paintTableWidget->setItem(row, 6, new QTableWidgetItem(query.value("quantity").toString()));

        // Display the image
        QString imagePath = query.value("image_path").toString();

        // Qlabel is a Qt class that displays an image or text
        // Create a pointer 'imageLabel', which points to a new instance of QLabel.
        QLabel *imageLabel = new QLabel();
        if (!imagePath.isEmpty()) {
            // setPixmap(...): Sets the scaled image to be displayed in the labelImage widget.
            // QPixmap(imagePath): Loads the image from the file path stored in imagePath
            imageLabel->setPixmap(QPixmap(imagePath).scaled(50, 50, Qt::KeepAspectRatio));
            // Store the image path in the QLabel property
            imageLabel->setProperty("imagePath", imagePath);
        }
        ui->paintTableWidget->setCellWidget(row, 7, imageLabel);

        row++;
    }
}


void MainWindow::on_buttonClearAddedList_clicked()
{
    // Clear the paint addition display field (list widget)
    ui->paintListWidget->clear();
    ui->labelImage->clear();
}


void MainWindow::on_buttonClearDisplayList_clicked()
{
    // Clear the display all inventory table (table widget)
    ui->paintTableWidget->clear();
    ui->labelListTitle->clear();
}


// Delete an item from inventory
void MainWindow::on_buttonDelete_clicked()
{
    QSqlQuery query;
    for (int row = 0; row < ui->paintTableWidget->rowCount(); ++row) {
        QTableWidgetItem *checkboxItem = ui->paintTableWidget->item(row, 0);

        // If the item's checkbox is selected
        if (checkboxItem->checkState() == Qt::Checked) {

            // Assigns the value of the "id" field from the database query to the checkbox item using 'Qt::UserRole' (user defined data)
            // This allows the checkbox item to store the database ID for later use such as editing or deleting
            // Need to convert to int because checkboxItem->data(Qt::UserRole) returns a 'QVariant' object that can hold any datatype
            int id = checkboxItem->data(Qt::UserRole).toInt();

            // Prepare the query by assigning the variable 'id' to the placeholder ':id'
            query.prepare("DELETE FROM paints WHERE id = :id");
            // the prepared query will use the value of 'id' to find and delete the specific row in the paints table where the id column matches this value.
            query.bindValue(":id", id);
            if (!query.exec()) {
                 // 'qDebug()' starts the debug logging and is Qt specific, it is comparable to 'std::cout'
                qDebug() << "Error deleting item with id " << id << ":" << query.lastError();
            }
        }
    }
    // Refresh the table display
    on_buttonDisplayPaints_clicked();
}


void MainWindow::on_buttonEdit_clicked()
{
    for (int row = 0; row < ui->paintTableWidget->rowCount(); ++row) {
        QTableWidgetItem *checkboxItem = ui->paintTableWidget->item(row, 0);

        // If the item's checkbox is selected
        if (checkboxItem->checkState() == Qt::Checked) {

            // Assigns the value of the "id" field from the database query to the checkbox item using 'Qt::UserRole' (user defined data)
            // This allows the checkbox item to store the database ID for later use such as editing or deleting
            // Need to convert to int because checkboxItem->data(Qt::UserRole) returns a 'QVariant' object that can hold any datatype
            int id = checkboxItem->data(Qt::UserRole).toInt();

            // Retrieve the text from the cell at the specified row and column in the paintTableWidget and assign it to the corresponding variables brand, color, etc.
            QString brand = ui->paintTableWidget->item(row, 1)->text();
            QString color = ui->paintTableWidget->item(row, 2)->text();
            QString itemNumber = ui->paintTableWidget->item(row, 3)->text();
            QString type = ui->paintTableWidget->item(row, 4)->text();
            QString collection = ui->paintTableWidget->item(row, 5)->text();
            QString quantity = ui->paintTableWidget->item(row, 6)->text();

            // Retrieve the image
            // Create a pointer that points to the widget containing the image
            // 'cellWidget(row, 7)' retrieves the widget at the specified row and column (5) within the QTableWidget.
            // Use qobject_cast to cast the widget pointer to a QLabel pointer. ((ui->paintTableWidget->cellWidget(row, 5)) returns a pointer to a QWidget)
            // This allows us to access QLabel-specific methods and properties.
            QLabel *imageLabel = qobject_cast<QLabel*>(ui->paintTableWidget->cellWidget(row, 7));

            // Display the image
            // 'imageLabel->property("imagePath")' gets the value of the 'imagePath' property from the imageLabel
            // Need to convert to string because 'imageLabel->property("imagePath").toString()' returns a 'QVariant' object that can hold any datatype
            QString imagePath = imageLabel->property("imagePath").toString();

            // Open the edit dialog window with current values
            // Create an instance of the EditDialog window object
            // '(this)' sets the parent of the editDialog instance to the current instance of the MainWindow class.
            EditDialog editDialog(this);
            // Set the values of the editDialog instance with the current paint details
            editDialog.setValues(brand, color, itemNumber, type, collection, quantity, imagePath);

            // 'editDialog.exec()' opens the dialog window and blocks input to other windows
            // 'QDialog::Accepted' and 'QDialog::Rejected' correspond to when the user clicks the built-in 'OK' or 'CANCEL' buttons in the window
            // If the user has clicked 'OK', assign the input values to newBrand, newColor, etc.
            if (editDialog.exec() == QDialog::Accepted) {
                QString newBrand = editDialog.getBrand();
                QString newColor = editDialog.getColor();
                QString newItemNumber = editDialog.getItemNumber();
                QString newType = editDialog.getType();
                QString newCollection = editDialog.getCollection();
                QString newQuantity = editDialog.getQuantity();
                QString newImagePath = editDialog.getImagePath();

                QSqlQuery query;

                // Prepare the query, inserting the new records brand, color etc. with the values :brand, :type, etc.
                query.prepare("UPDATE paints SET brand = :brand, color = :color, item_number = :item_number, type = :type, collection = :collection, quantity = :quantity, image_path = :image_path WHERE id = :id");

                // Bind the input variable values to the respective placeholders
                query.bindValue(":brand", newBrand);
                query.bindValue(":color", newColor);
                query.bindValue(":item_number", newItemNumber);
                query.bindValue(":type", newType);
                query.bindValue(":collection", newCollection);
                query.bindValue(":quantity", newQuantity);
                query.bindValue(":image_path", newImagePath);
                query.bindValue(":id", id);
                if (!query.exec()) {
                    // 'qDebug()' starts the debug logging and is Qt specific, it is comparable to 'std::cout'
                    qDebug() << "Error updating item with id " << id << ":" << query.lastError();
                } else {
                    qDebug() << "Successfully updated item with id " << id;
                }
            }
        }
    }
    // Refresh the table display
    on_buttonDisplayPaints_clicked();
}


void MainWindow::on_buttonSearch_clicked()
{
    // Sets the title of the list being displayed
    ui->labelListTitle->setText("Viewing Search Results");

    // Get the search term from the input field
    QString searchTerm = ui->inputSearch->text();

    // If the search term is empty, do nothing
    if (searchTerm.isEmpty()) {
        return;
    }

    QSqlQuery query;

    // Construct an SQL query string to search for paints matching the search term in any of the columns: brand, color, type, or item_number.
    // The search term is inserted into the query using QString's arg() method, which safely replaces '%1' with the actual search term.
    QString searchQuery = QString("SELECT id, brand, color, item_number, type, collection, quantity, image_path FROM paints WHERE "
                                  "brand LIKE '%%1%' OR color LIKE '%%1%' OR item_number LIKE '%%1%' OR type LIKE '%%1%' OR collection LIKE '%%1%' OR quantity LIKE '%%1%'")
                              .arg(searchTerm);

    if (!query.exec(searchQuery)) {
        // 'qDebug()' starts the debug logging and is Qt specific, it is comparable to 'std::cout'
        qDebug() << "Error searching for term:" << query.lastError();
        return;
    }

    // Display the list in the table
    // Set column count and headers for QTableWidget, this includes 1 column for the checkboxes
    ui->paintTableWidget->setColumnCount(8);

    // Set the titles of each column in the table
    QStringList headers;
    headers << "Select" << "Brand" << "Color" << "Item Number" << "Type" << "Collection" << "Quantity" << "Image";
    ui->paintTableWidget->setHorizontalHeaderLabels(headers);

    // Clear existing rows (refresh if there is a list is already displayed)
    ui->paintTableWidget->setRowCount(0);

    // Iterate through the results and populate the table
    int row = 0;
    while (query.next()) {
        ui->paintTableWidget->insertRow(row);

        // Represents an item in the QTableWidget, in this case it's a selection/checkbox for each row
        QTableWidgetItem *checkboxItem = new QTableWidgetItem();

        // Sets the item's checkbox to be unchecked
        checkboxItem->setCheckState(Qt::Unchecked);

        // Assigns the value of the "id" field from the database query to the checkbox item using 'Qt::UserRole' (user defined data)
        // This allows the checkbox item to store the database ID for later use such as editing or deleting
        checkboxItem->setData(Qt::UserRole, query.value("id"));

        // Populate each row of the paintTableWidget with data retrieved from the database query.
        ui->paintTableWidget->setItem(row, 0, checkboxItem);

        // Need to convert to string because query.value(column_name) returns a 'QVariant' object that can hold any datatype
        ui->paintTableWidget->setItem(row, 1, new QTableWidgetItem(query.value("brand").toString()));
        ui->paintTableWidget->setItem(row, 2, new QTableWidgetItem(query.value("color").toString()));
        ui->paintTableWidget->setItem(row, 3, new QTableWidgetItem(query.value("item_number").toString()));
        ui->paintTableWidget->setItem(row, 4, new QTableWidgetItem(query.value("type").toString()));
        ui->paintTableWidget->setItem(row, 5, new QTableWidgetItem(query.value("collection").toString()));
        ui->paintTableWidget->setItem(row, 6, new QTableWidgetItem(query.value("quantity").toString()));


        // Display the image
        QString imagePath = query.value("image_path").toString();

        // Qlabel is a Qt class that displays an image or text
        // Create a pointer 'imageLabel', which points to a new instance of QLabel.
        QLabel *imageLabel = new QLabel();
        if (!imagePath.isEmpty()) {
            // setPixmap(...): Sets the scaled image to be displayed in the labelImage widget.
            // QPixmap(imagePath): Loads the image from the file path stored in imagePath
            imageLabel->setPixmap(QPixmap(imagePath).scaled(50, 50, Qt::KeepAspectRatio));
            // Store the image path in the QLabel property
            imageLabel->setProperty("imagePath", imagePath);
        }
        ui->paintTableWidget->setCellWidget(row, 7, imageLabel);

        row++;
    }
}


void MainWindow::on_buttonAddToShopping_clicked()
{
    QSqlQuery query;

    for (int row = 0; row < ui->paintTableWidget->rowCount(); ++row) {
        QTableWidgetItem *checkboxItem = ui->paintTableWidget->item(row, 0);

        // If the item's checkbox is selected
        if (checkboxItem->checkState() == Qt::Checked) {

            // Retrieve the id of the paint item that was previously stored in the checkbox item when the list was populated using 'Qt::UserRole' (user defined data)
            QVariant idVariant = checkboxItem->data(Qt::UserRole);

            // Check to see that the id value is not null
            if (idVariant.isValid()) {
                int id = idVariant.toInt(); // Convert the QVariant to int

                // Prepare query to change shopping list attribute to TRUE
                query.prepare("UPDATE paints SET shopping_list = 1 WHERE id = :id");
                query.bindValue(":id", id); // Bind the id value to the respective placeholder

                if (!query.exec()) {
                    qDebug() << "Error adding item to shopping list " << id << ":" << query.lastError();
                } else {
                    qDebug() << "Successfully added item with id " << id << " to shopping list";
                }
            } else {
                qDebug() << "Invalid id for row " << row;
            }
        }
    }
    // Refresh the table display
    on_buttonDisplayShoppingList_clicked();
}


void MainWindow::on_buttonRemoveFromShoppingList_clicked()
{
    QSqlQuery query;
    for (int row = 0; row < ui->paintTableWidget->rowCount(); ++row) {
        QTableWidgetItem *checkboxItem = ui->paintTableWidget->item(row, 0);

        // If the item's checkbox is selected
        if (checkboxItem->checkState() == Qt::Checked) {

            // Retrieve the id of the paint item that was previously stored in the checkbox item when the list was populated using 'Qt::UserRole' (user defined data)
            QVariant idVariant = checkboxItem->data(Qt::UserRole);

            // Check to see that the id value is not null
            if (idVariant.isValid()) {

                // Convert the QVariant to int
                int id = idVariant.toInt();

                // Prepare query to change shopping list attribute to TRUE
                query.prepare("UPDATE paints SET shopping_list = 0 WHERE id = :id");

                // Bind the id value to the respective placeholder
                query.bindValue(":id", id);

                if (!query.exec()) {
                    qDebug() << "Error removing item from shopping list " << id << ":" << query.lastError();
                } else {
                    qDebug() << "Successfully removed item with id " << id << " from shopping list";
                }
            } else {
                qDebug() << "Invalid id for row " << row;
            }
        }
    }
    // Refresh the table display
    on_buttonDisplayShoppingList_clicked();
}


void MainWindow::on_buttonUploadImage_clicked()
{
    // Explaination of "QString fileName = QFileDialog::getOpenFileName(this, "Open Image", "", "Image Files (*.png *.jpg *.bmp)");":
    // 'fileName' stores the path of the selected file as a string
    // 'getOpenFileName' opens a dialog window for the user to select a file
    // the 'this' pointer refers to the parent widget (in this case, the current instance of the EditDialog class)
    // "Open Image" is the title of the window
    // "" is the initial directory where the dialog will open, an empty string means it will use the root directory by default
    // The last parameter is a filter to show only the file types allowed for upload
    QString fileName = QFileDialog::getOpenFileName(this, "Open Image", "", "Image Files (*.png *.jpg *.bmp)");
    if (!fileName.isEmpty()) {
        // setPixmap(...): Sets the scaled image to be displayed in the labelImage widget.
        // QPixmap(fileName): Loads the image from the file path stored in fileName
        ui->labelImage->setPixmap(QPixmap(fileName).scaled(100, 100, Qt::KeepAspectRatio));
        // Store the selected image path (declared in the mainwindow.h header file)
        selectedImagePath = fileName;
    }
}

